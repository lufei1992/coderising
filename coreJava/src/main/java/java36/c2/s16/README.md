# synchronized底层实现？锁升级、降级？
>
- synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的，**Monitor 对象**是同步的基本实现单元。
- 在 Java 6 之前，Monitor 的实现完全是**依靠操作系统内部的互斥锁**，因为需要进行用户态到内核态的切换，所以同步操作是一个**无差别的重量级操作**。
- 现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：**偏斜锁**（Biased Locking）、**轻量级锁**和**重量级锁**，大大改进了其性能。
- 所谓锁的升级、降级，就是 **JVM 优化 synchronized 运行的机制**，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。
>
- 当没有竞争出现时，**默认会使用偏斜锁**。JVM 会利用 **CAS 操作**（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。
- 如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并**切换到轻量级锁实现**。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。
- 注意,有的观点认为 Java 不会进行锁降级。实际上，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。
>
- synchronized 是 JVM 内部的 Intrinsic Lock，所以偏斜锁、轻量级锁、重量级锁的代码实现，并不在核心类库部分，而是在 JVM 的代码中。
- Java 代码运行可能是解释模式也可能是编译模式，所以对应的同步逻辑实现，也会分散在不同模块下，
>
- 首先，synchronized 的行为是 JVM runtime 的一部分，所以我们需要先找到 Runtime 相关的功能实现。通过在代码中查询类似“monitor_enter”或“Monitor Enter”，很直观的就可以定位到：
- sharedRuntime.cpp/hpp，它是解释器和编译器运行时的基类。
- synchronizer.cpp/hpp，JVM 同步相关的各种基础逻辑。
- ......
>
### 你知道“自旋锁”是做什么的吗？它的使用场景是什么？
