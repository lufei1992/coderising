# String、StringBuffer、StringBuilder
>
## String
- String是Java非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。
- 是典型的Immutable类，被声明为final class，所有属性也都是final的。
- 由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。
- 由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。
>
## StringBuffer
- StringBuffer是为解决上面提到的拼接产生太多中间对象的问题而提供的一个类，
- 可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。
- 保证线程安全，也随着带来了额外的性能开销。
>
## StringBuilder
- 能力上与StringBuffer没有本质区别，但是去掉了线程安全的部分，
- 有效减小了开销，是绝大部分情况下进行字符串拼接的首选。
>
## 字符串设计和实现考量
- String是Immutable类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改。
- StringBuffer的线程安全是通过把各种修改数据的方法都加上synchronized关键字实现的，非常直白。
- 为了实现修改字符序列的目的，StringBuffer和StringBuilder底层都是利用可修改的（char，JDK9以后是byte）数组，二者都继承了AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了synchronized。
>
## 字符串缓存
- 把常见应用进行堆转储（Dump Heap），平均25%的对象是字符串，其中约半数是重复的。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建开销。
- intern() 方法，被缓存的字符串存在所谓的PermGen里，即“永久代”，不会被 FullGC之外的垃圾收集照顾到。如果使用不当，OOM就会光顾。
- 后续版本中，这个缓存放置在堆中，极大地避免了永久代占满的问题。
>
- 在运行时，字符串的一些基础操作会直接利用JVM内部的Intrinsic机制，往往运行的就是特殊优化的本地代码，而根本就不是Java代码生成的字节码。
- Intrinsic可以简单理解为，是一种利用native方式hard-coded的逻辑，算是一种特别的内联，很多优化还是需要直接使用特定的CPU指令。
>
## String自身的演化
- 在历史版本中，它是使用char数组来存数据的，这样非常直接。
- 但是Java中的char是两个byte 大小，拉丁语系语言的字符，根本就不需要太宽的char，这样无区别的实现就造成了一定的浪费。
- 密度是编程语言平台永恒的话题，因为归根结底绝大部分任务是要来操作数据的。
>
- 在Java 9 中，引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。
- 将数据存储方式从char数组，改变为一个byte数组加上一个标识编码的所谓coder，并且将相关字符串操作类都进行了修改。
- 另外，所有相关的Intrinsic之类也都进行了重写，以保证没有任何性能损失。
>
- 但是，在极端情况下，字符串也出现了一些能力退化，比如最大字符串的大小。
- 原来char数组的实现，字符串的最大长度就是数组本身的长度限制，
- 但是替换成byte数组，同样数组长度下，存储能力是退化了一倍的！
>
- 紧凑字符串带来的优势：
- 即更小的内存占用、更快的操作速度。