# int & Integer
>
- Java的8个原始数据类型（boolean、byte、char、short、int、long、float、double）。Java语言虽然号称一切都是对象，但原始数据类型是例外。
- Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间转换。Java 5 中，引入了自动装箱和自动拆箱，Java可以根据上下文，自动进行转换，极大地简化了相关编程。
- Integer的默认缓存是-128到127之间。
>
## 自动装箱、拆箱
- 自动装箱实际上算是一种语法糖。Java平台为我们自动进行了一些转换，保证不同的写法在运行时等价。它们发生在编译阶段，也就是生成的字节码是一致的。
- javac 替我们自动把装箱转换为Integer.valueOf()，把拆箱替换为Integer.intValue()
>
- 缓存机制并不是只有Integer才有，同样存在于其他的一些包装类，比如
- Boolean，缓存了 true/false 对应实例，确切说，只会返回两个常量实例 Boolean.TRUE/FALSE
- Short，同样是缓存了-128到127之间的数值
- Byte，数值有限，所以全部被缓存
- Character，缓存范围'\u0000'到'\u007F'
>
- 原则上，避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建10万个Java对象和10万个整数的开销可不是一个数量级的。
- 常见的线程安全计数器实现：
>
## 源码分析
- 阅读并实践高质量代码是程序员成长的必经之路
>
- Integer的职责：包括各种基础的常量，比如最大值、最小值、位数等，各种静态工厂方法valueOf()；获取环境变量数值的方法；各种转换方法
- 1 缓存 -XX:AutoBoxCacheMax=N
- 缓存的实现，体现在 java.lang.Integer源码之中，并实现在IntegerCache 的静态初始化块里。
>
- 2 包装类里存储数值的成员变量“value”，都被声明为“private final”，是不可变类型。
- 这种设计是可以理解的，或者说是必须的选择。
>
## 原始类型线程安全
- 原始数据类型的变量，显然要使用并发相关手段，才能保证线程安全。如果有线程安全的计算需要，建议使用AtomicInteger、AtomicLong这样的线程安全类。
- 特别的是，部分比较宽的数据类型，比如float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值。
>
## Java原始数据类型和引用类型局限性
>
- 原始数据类型和Java泛型不能配合使用
>
### Java对象的内存结构？对象头的结构？如何计算或者获取某个Java对象的大小？
>

